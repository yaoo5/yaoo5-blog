# 常见限流算法
本文将介绍以下四种常见的限流算法，并使用 `Node.js` + `redis` 实现：
- 固定窗口限流
- 滑动窗口限流
- 漏桶算法
- 令牌桶算法

## 固定窗口限流

### 原理
原理就是对一段固定时间窗口内的请求进行计数，如果请求数超过了阈值，则舍弃该请求；如果没有达到设定的阈值，则接受该请求，且计数加1。当时间窗口结束时，重置计数器为0。

### 代码实现
<<< @/codes/rate-limit/fixed-window.ts#middleware

### 测试一下
<<< @/codes/rate-limit/fixed-window.ts#example

### 缺点
会出现两倍流量配置的情况。

> 完整代码请点击[这里](https://github.com/yaoo5/yaoo5.github.io/blob/main/docs/codes/rate-limit/fixed-window.ts)。

## 滑动窗口限流
**滑动窗口限流**解决固定窗口临界值的问题。它将单位时间周期分为n个小周期，分别记录每个小周期内接口的访问次数，并且根据时间滑动删除过期的小周期。

### 代码实现
<<< @/codes/rate-limit/sliding-window.ts#middleware

### 测试一下
<<< @/codes/rate-limit/sliding-window.ts#example

### 缺点
滑动窗口算法虽然解决了固定窗口的临界问题，但是一旦到达限流后，请求都会直接被暴力被拒绝。酱紫我们会损失一部分请求，这其实对于产品来说，并不太友好。

## 漏桶算法
漏桶算法面对限流，就更加的柔性，不存在直接的粗暴拒绝。

它的原理很简单，可以认为就是注水漏水的过程。往漏桶中以任意速率流入水，以固定的速率流出水。当水超过桶的容量时，会被溢出，也就是被丢弃。因为桶容量是不变的，保证了整体的速率。

### 代码实现
<<< @/codes/rate-limit/leaky-bucket.ts#middleware

### 测试一下
<<< @/codes/rate-limit/leaky-bucket.ts#example

### 缺点
在正常流量的时候，系统按照固定的速率处理请求，是我们想要的。但是面对突发流量的时候，漏桶算法还是循规蹈矩地处理请求，这就不是我们想看到的啦。流量变突发时，我们肯定希望系统尽量快点处理请求，提升用户体验嘛。

## 令牌桶算法
面对突发流量的时候，我们可以使用令牌桶算法限流。

令牌桶算法原理：
- 根据限流大小，定时往令牌桶里放令牌。
- 如果令牌数量满了，超过令牌桶容量的限制，那就丢弃。
- 系统在接受到一个用户请求时，都会先去令牌桶要一个令牌。如果拿到令牌，那么就处理这个请求的业务逻辑；
如果拿不到令牌，就直接拒绝这个请求。
### 代码实现

### 测试一下

### 缺点

