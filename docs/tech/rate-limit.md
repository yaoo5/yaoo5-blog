# 常见限流算法
本文将介绍以下四种常见的限流算法，并使用 `Node.js` + `redis` 实现：
- [固定窗口限流](#固定窗口限流)
- [滑动窗口限流](#滑动窗口限流)
- [漏桶算法](#漏桶算法)
- [令牌桶算法](#令牌桶算法)

## 固定窗口限流

### 原理
固定窗口限流就是对一段固定时间窗口内的请求进行计数。
- 如果请求数超过了阈值，则拒绝该请求；
- 如果请求数没超过阈值，则接受该请求，且计数加1。
- 当时间窗口结束时，重置计数器为0。

### 代码实现
<<< @/codes/rate-limit/fixed-window.ts#middleware

### 测试一下
<<< @/codes/rate-limit/fixed-window.ts#example

```shell
ab -n 10 -c 10 -k -s 1200 "http://localhost:3000/"
```

### 缺点
如图，临界值会出现两倍流量配置的情况。

![](/tech/images/rate-limit/fixed-window-short.png)

## 滑动窗口限流
**滑动窗口限流**解决固定窗口临界值的问题。它将单位时间周期分为n个小周期，分别记录每个小周期内接口的访问次数，并且根据时间滑动删除过期的小周期。

![](/tech/images/rate-limit/sliding-window-how.png)

### 代码实现
<<< @/codes/rate-limit/sliding-window.ts#middleware

### 测试一下
<<< @/codes/rate-limit/sliding-window.ts#example

```shell
ab -n 10 -c 10 -k -s 1200 "http://localhost:3000/"
```

### 缺点
滑动窗口算法虽然解决了固定窗口的临界问题，但是一旦到达限流后，请求都会直接被暴力被拒绝。酱紫我们会损失一部分请求，这其实对于产品来说，并不太友好。

## 漏桶算法
漏桶算法面对限流，就更加的柔性，不存在直接的粗暴拒绝。

它的原理很简单，可以认为就是注水漏水的过程。往漏桶中以任意速率流入水，以固定的速率流出水。当水超过桶的容量时，会被溢出，也就是被丢弃。因为桶容量是不变的，保证了整体的速率。

![](/tech/images/rate-limit/leaky-bucket-how.png)

### 代码实现

原理：
- 请求进来时，先计算当前请求滴出时间并将请求放入队列。
- 根据滴出时间清除队列中已经滴出的请求。
- 如果队列长度超过了桶的容量，则拒绝请求。

计算公式：请求滴出时间 = MAX(上次请求滴出时间 + 滴水间隔时间 ,当前时间)

> 举例
> 
> 当前时间：2024-04-26 13:00:00(1714107600000), 滴水间隔时间：1个/200ms；桶容量：5个；同时有5个请求进来
> - 第1个请求滴出时间 = MAX(0 + 200, 1714107600000) = 1714107600200
> - 第2个请求滴出时间 = MAX(1714107600200 + 200, 1714107600200) = 1714107600400
> - 第3个请求滴出时间 = MAX(1714107600400 + 200, 1714107600400) = 1714107600600
> - 第4个请求滴出时间 = MAX(1714107600600 + 200, 1714107600600) = 1714107600800
> - 第5个请求滴出时间 = MAX(1714107600800 + 200, 1714107600800) = 1714107601000

<<< @/codes/rate-limit/leaky-bucket.ts#middleware{26-29}

### 测试一下
<<< @/codes/rate-limit/leaky-bucket.ts#example

### 缺点
在正常流量的时候，系统按照固定的速率处理请求，是我们想要的。但是面对突发流量的时候，漏桶算法还是循规蹈矩地处理请求，这就不是我们想看到的啦。流量变突发时，我们肯定希望系统尽量快点处理请求，提升用户体验嘛。

## 令牌桶算法
面对突发流量的时候，我们可以使用令牌桶算法限流。

令牌桶算法原理：
- 根据限流大小，定时往令牌桶里放令牌。
- 如果令牌数量满了，超过令牌桶容量的限制，那就丢弃。
- 系统在接受到一个用户请求时，都会先去令牌桶要一个令牌。如果拿到令牌，那么就处理这个请求的业务逻辑；
如果拿不到令牌，就直接拒绝这个请求。


![](/tech/images/rate-limit/token-bucket-how.png)

### 代码实现

<<< @/codes/rate-limit/token-bucket.ts#middleware

### 测试一下

<<< @/codes/rate-limit/token-bucket.ts#example

### 缺点

如果令牌发放的策略正确，这个系统即不会被拖垮，也能提高机器的利用率。Google的Java开发工具包Guava中的RateLimiter类，就是基于令牌桶算法实现的。

## 拓展：Lua脚本是否可以用事务代替？
可以，但Redis事务存在一些缺陷
- 原子性的限制（如图）

  ![](/tech/images/rate-limit/redis-atom.png)

- 不支持条件操作：事务不支持条件操作，例如基于当前值来更新某个键的值。

- 事务中的每条命令都会与redis服务器进行网络交互

## 总结

| 算法     |        优点        |              缺点 | 使用场景 |
|--------|:----------------:|----------------:|-----:|
| 固定窗口限流 |        简单        |         存在临界值问题 |   -- |
| 滑动窗口限流 |  解决了固定窗口的临界值问题   | 达到限流后，对后续请求暴力拒绝 |   -- |
| 漏桶算法   | 面对限流更加柔和，不存在暴力拒绝 |     面对突发流量，循规蹈矩 |   -- |
| 令牌桶算法  |    解决了突发流量的问题    |           无明显缺点 |   -- |

::: tip
完整代码请点击[这里](https://github.com/yaoo5/yaoo5.github.io/blob/main/docs/codes/rate-limit/)。
:::

